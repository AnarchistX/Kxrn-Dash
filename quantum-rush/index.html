<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="../">
    <title>Quantum Rush</title>
    <style>
        body {
            background: #0d0d1a url('https://www.transparenttextures.com/patterns/stardust.png');
            margin: 0;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
        }
        #gameCanvas {
            border: 2px solid #00FFFF;
            box-shadow: 0 0 20px #00FFFF;
            background: linear-gradient(to bottom, #1a1a2e, #16213e);
            display: none;
        }
        #score, #attempts {
            color: #00FFFF;
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            position: fixed;
            text-shadow: 0 0 10px #00FFFF;
            z-index: 100;
        }
        #score { top: 20px; left: 56px; }
        #attempts { top: 20px; right: 20px; }
        #homeBtn {
            position: fixed;
            top: 12px;
            left: 12px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00FFFF;
            border: 1px solid #00FFFF;
            background: rgba(10, 20, 35, 0.6);
            text-decoration: none;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            line-height: 1;
            border-radius: 4px;
            box-shadow: 0 0 10px #00FFFF66;
            z-index: 2000;
        }
        #homeBtn:hover {
            background: rgba(10, 20, 35, 0.85);
            box-shadow: 0 0 14px #00FFFFAA;
        }
        #menu, #gameOver, #pauseMenu, #orientationPrompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #00FFFF;
            background: rgba(26, 26, 46, 0.95);
            padding: 40px;
            border: 2px solid #00FFFF;
            box-shadow: 0 0 30px #00FFFF;
            z-index: 1000;
        }
        #gameOver, #pauseMenu, #orientationPrompt { display: none; }
        h1 {
            font-size: 64px;
            margin-bottom: 20px;
            text-shadow: 0 0 15px #00FFFF;
            letter-spacing: 5px;
        }
        button {
            font-size: 24px;
            padding: 15px 30px;
            margin: 10px;
            background: #00FFFF;
            color: #1a1a2e;
            border: none;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            box-shadow: 0 0 10px #00FFFF;
            min-width: 200px;
        }
        button:hover {
            background: #00CCCC;
            box-shadow: 0 0 20px #00CCCC;
        }
        .grid {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            background-image: linear-gradient(#00FFFF22 1px, transparent 1px),
                            linear-gradient(90deg, #00FFFF22 1px, transparent 1px);
            background-size: 20px 20px;
            z-index: -1;
        }
        @media only screen and (max-width: 1024px) {
            #gameCanvas {
                width: 100vw;
                height: 100vh;
                max-width: none;
                max-height: none;
            }
            #score, #attempts {
                font-size: 24px;
            }
            h1 {
                font-size: 48px;
            }
            button {
                font-size: 20px;
                padding: 10px 20px;
                min-width: 150px;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
</head>
<body>
    <a id="homeBtn" href="/" title="Home">‚Üê</a>
    <div class="grid"></div>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Score: 0</div>
    <div id="attempts">Attempts: 0</div>
    <div id="menu">
        <h1>QUANTUM RUSH</h1>
        <button onclick="startGame()">PLAY</button>
        <button onclick="togglePracticeMode()">PRACTICE MODE</button>
    </div>
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p id="finalScore">Score: 0</p>
        <button onclick="restartGame()">TRY AGAIN</button>
        <button onclick="showMenu()">MAIN MENU</button>
    </div>
    <div id="pauseMenu">
        <h1>PAUSED</h1>
        <button onclick="resumeGame()">RESUME</button>
        <button onclick="restartGame()">RESTART</button>
        <button onclick="showMenu()">MAIN MENU</button>
    </div>
    <div id="orientationPrompt">
        <h1>PLEASE ROTATE</h1>
        <p>For the best experience, please rotate your device to landscape mode.</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Create and preload sound effects
        const coinSound = new Audio('assets/sounds/SFX/coin collect.mp3');
        const deathSound = new Audio('assets/sounds/SFX/death sci-fi.mp3');
        const backgroundMusic = new Audio();
        
        coinSound.preload = 'auto';
        deathSound.preload = 'auto';
        
        let soundEnabled = false;
        let currentTrackIndex = 0;

        // Create clones for overlapping sounds
        const createSoundPool = (originalSound, poolSize = 3) => {
            const pool = [originalSound];
            for (let i = 1; i < poolSize; i++) {
                const clone = originalSound.cloneNode();
                clone.volume = originalSound.volume;
                pool.push(clone);
            }
            return pool;
        };

        const coinSoundPool = createSoundPool(coinSound);
        let currentCoinSound = 0;

        function playSoundFromPool(pool) {
            if (!soundEnabled) return;
            try {
                const sound = pool[currentCoinSound];
                sound.currentTime = 0;
                sound.play().catch(error => console.error('Error playing sound:', error));
                currentCoinSound = (currentCoinSound + 1) % pool.length;
            } catch (error) {
                console.error('Error playing sound from pool:', error);
            }
        }

        function playSound(sound) {
            if (!sound || !soundEnabled) return;
            try {
                if (sound === coinSound) {
                    playSoundFromPool(coinSoundPool);
                } else {
                    sound.currentTime = 0;
                    sound.play().catch(error => console.error('Error playing sound:', error));
                }
            } catch (error) {
                console.error(`Error playing sound:`, error);
            }
        }

        function initSound() {
            if (soundEnabled) return;
            soundEnabled = true;
            
            // Set volumes
            coinSound.volume = 0.4;
            deathSound.volume = 0.3;
            backgroundMusic.volume = 0.6;
            backgroundMusic.preload = 'auto';
            
            // Initialize coin sound pool
            coinSoundPool.forEach(sound => {
                sound.volume = coinSound.volume;
            });

            // Set up background music
            backgroundMusic.addEventListener('ended', playNextTrack);
            // Do not autoplay here; we start playback after a user gesture in startGame()

            // Set up Web Audio analyser for beat-reactive visuals
            try {
                const Ctx = window.AudioContext || window.webkitAudioContext;
                if (Ctx && !game.audioCtx) {
                    game.audioCtx = new Ctx();
                }
                if (game.audioCtx && !game.mediaSourceReady) {
                    game.analyser = game.audioCtx.createAnalyser();
                    game.analyser.fftSize = 256;
                    game.freqData = new Uint8Array(game.analyser.frequencyBinCount);
                    const src = game.audioCtx.createMediaElementSource(backgroundMusic);
                    src.connect(game.analyser);
                    game.analyser.connect(game.audioCtx.destination);
                    game.mediaSourceReady = true;
                }
            } catch (e) {
                console.warn('Web Audio init failed:', e);
            }

            // Pre-select and preload a random music track to reduce start delay
            try {
                let preIndex = Math.floor(Math.random() * musicPlaylist.length);
                currentTrackIndex = preIndex;
                backgroundMusic.src = musicPlaylist[currentTrackIndex];
                // Attempt to preload/buffer before user gesture
                backgroundMusic.load();
                backgroundMusic.addEventListener('canplaythrough', () => {
                    game.musicReady = true;
                }, { once: true });
            } catch (e) {
                console.warn('Music preload failed:', e);
            }
        }

        const musicPlaylist = [
            'assets/sounds/music/Astral Siren\'s Call.m4a',
            'assets/sounds/music/Bioluminescence Protocol.m4a',
            'assets/sounds/music/Digital Awakening.m4a',
            'assets/sounds/music/Digital Lattice.m4a',
            'assets/sounds/music/Digital Pursuit.m4a',
            'assets/sounds/music/Digital Silk Stream.m4a',
            'assets/sounds/music/Digital Velocity.m4a',
            'assets/sounds/music/Quantum Rush.m4a',
            'assets/sounds/music/Quantum Seduction.m4a',
            'assets/sounds/music/System Genesis.m4a'
        ];

        function playRandomTrack() {
            if (!soundEnabled) return;
            try {
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * musicPlaylist.length);
                } while (newIndex === currentTrackIndex && musicPlaylist.length > 1);
                
                currentTrackIndex = newIndex;
                backgroundMusic.src = musicPlaylist[currentTrackIndex];
                backgroundMusic.play().catch(error => console.error('Error playing background music:', error));
            } catch (error) {
                console.error('Error playing background music:', error);
            }
        }

        function playNextTrack() {
            currentTrackIndex = (currentTrackIndex + 1) % musicPlaylist.length;
            backgroundMusic.src = musicPlaylist[currentTrackIndex];
            backgroundMusic.play().catch(error => console.error('Error playing next track:', error));
        }

        // === Sci-Fi: Parallax Starfield and Speed Lines ===
        const starfield = {
            layers: [
                { stars: [], speed: 0.15, color: 'rgba(0,255,255,0.15)', size: 1.5 },
                { stars: [], speed: 0.35, color: 'rgba(0,255,255,0.25)', size: 2.0 },
                { stars: [], speed: 0.7,  color: 'rgba(255,255,255,0.35)', size: 1.0 }
            ]
        };

        function initStarfield() {
            starfield.layers.forEach(layer => {
                const count = Math.floor((canvas.width * canvas.height) / 25000);
                layer.stars = Array.from({ length: count }, () => ({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height
                }));
            });
        }

        function drawStarfield() {
            starfield.layers.forEach(layer => {
                ctx.save();
                ctx.fillStyle = layer.color;
                const beatBoost = 0.9 + (game.beat || 0) * 0.4;
                ctx.globalAlpha = beatBoost;
                layer.stars.forEach(star => {
                    let screenX = star.x - game.cameraX * layer.speed;
                    // wrap
                    screenX = ((screenX % canvas.width) + canvas.width) % canvas.width;
                    ctx.beginPath();
                    ctx.arc(screenX, star.y, layer.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.restore();
            });
        }

        function drawSpeedLines() {
            if (!game.showSpeedLines) return;
            const lines = 20;
            for (let i = 0; i < lines; i++) {
                const x = Math.random() * canvas.width;
                const length = 20 + Math.random() * 60;
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.15)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x + 50, length);
                ctx.stroke();
            }
        }

        function groundY() { return canvas.height - 100; }
        function groundTop() { return groundY() - 2; }

        const player = {
            x: 200,
            y: groundTop() - 40,
            width: 40,
            height: 40,
            velocity: 0,
            worldX: 200,
            isAlive: true,
            jumping: false,
            trail: []
        };

        const game = {
            running: false,
            isPaused: false,
            speed: 10,
            baseSpeed: 10,
            maxSpeed: 14,  // Capped speed for manageability
            jumpForce: -18, // Original snappy jump
            gravity: 1.0,  // Original gravity for quick drops
            score: 0,
            coinCount: 0,
            attempts: 0,
            obstacles: [],
            coins: [],
            particles: [],
            effects: [], // transient VFX like shockwaves
            difficulty: 1,
            checkpoints: [],
            lastCheckpoint: null,
            isPracticeMode: false,
            cameraX: 0,
            jumpPressed: false,
            // Sci-Fi: speed boost state
            extraSpeed: 0,
            speedBoostTimer: 0,
            speedBoostAmount: 6,
            showSpeedLines: false,
            // Audio/beat-reactive
            audioCtx: null,
            analyser: null,
            freqData: null,
            beat: 0,
            beatSmoothed: 0,
            mediaSourceReady: false,
            musicReady: false
        };

        function generateObstacles(startX) {
            // Slower difficulty increase, capped at 2.5
            game.difficulty = 1 + Math.min(1.5, game.score / 2000);
            game.speed = Math.min(game.maxSpeed, game.baseSpeed + (game.difficulty - 1) * 2);

            if (Math.random() < 0.7) {  
                const coinY = canvas.height - 230 + Math.random() * 100;
                game.coins.push({
                    x: startX + Math.random() * 300,
                    y: coinY,
                    width: 20,
                    height: 20,
                    rotation: 0,
                    collected: false
                });
            }

            const spikeChance = 0.3 + (game.difficulty - 1) * 0.05;
            const portalChance = 0.12 + (game.difficulty - 1) * 0.03;
            let type;
            const r = Math.random();
            if (r < spikeChance) {
                type = 'spike';
            } else if (r < spikeChance + portalChance) {
                type = 'portal';
            } else {
                const pool = ['platform', 'gap'];
                type = pool[Math.floor(Math.random() * pool.length)];
            }
            
            switch(type) {
                case 'spike':
                    const spikeCount = Math.min(2, Math.floor(Math.random() * game.difficulty + 1));
                    for(let i = 0; i < spikeCount; i++) {
                        game.obstacles.push({
                            x: startX + (i * 50),
                            y: groundTop() - 40,
                            width: 40,
                            height: 40,
                            type: 'spike'
                        });
                    }
                    break;
                case 'platform':
                    const minHeight = canvas.height - 230 - ((game.difficulty - 1) * 30);
                    const platformHeight = minHeight + Math.random() * 100;
                    game.obstacles.push({
                        x: startX,
                        y: platformHeight,
                        width: 200,
                        height: 20,
                        type: 'platform'
                    });
                    if (Math.random() < 0.2 * game.difficulty) {
                        const spikeX = startX + Math.random() * 160;
                        game.obstacles.push({
                            x: spikeX,
                            y: platformHeight - 40,
                            width: 40,
                            height: 40,
                            type: 'spike'
                        });
                    }
                    break;
                case 'portal':
                    game.obstacles.push({
                        x: startX + 100 + Math.random() * 150,
                        y: canvas.height - 180,
                        width: 26,
                        height: 80,
                        type: 'portal',
                        activated: false,
                        phase: 0
                    });
                    break;
                case 'gap':
                    const gapWidth = 100 + (game.difficulty - 1) * 10;
                    break;
            }

            // Chance to add a jump pad near ground
            if (Math.random() < 0.22) {
                game.obstacles.push({
                    x: startX + 60 + Math.random() * 200,
                    y: groundTop() - 12,
                    width: 80,
                    height: 12,
                    type: 'pad'
                });
            }
            // Chance to add an air orb above ground
            if (Math.random() < 0.28) {
                game.obstacles.push({
                    x: startX + 120 + Math.random() * 220,
                    y: groundTop() - (140 + Math.random() * 120),
                    width: 24,
                    height: 24,
                    type: 'orb',
                    used: false,
                    phase: 0
                });
            }
        }

        function createParticles(x, y, color, count = 10) {
            for(let i = 0; i < count; i++) {
                game.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.random() * 5 + 2,
                    color: color,
                    life: 1
                });
            }
        }

        function startGame() {
            if (isMobile() && window.innerHeight > window.innerWidth) return;
            hideAllMenus();
            canvas.style.display = 'block';
            game.running = true;
            game.isPracticeMode = false;
            
            // Initialize sound system
            if (!soundEnabled) {
                initSound();
                // Add a one-time click handler for browser autoplay policy
                const enableSound = () => {
                    coinSound.play().then(() => {
                        coinSound.pause();
                        coinSound.currentTime = 0;
                        // Resume Web Audio context on user gesture if suspended
                        if (game.audioCtx && game.audioCtx.state === 'suspended') {
                            game.audioCtx.resume().catch(() => {});
                        }
                        const startMusic = () => {
                            backgroundMusic.play().catch(err => console.error('Music play error:', err));
                        };
                        if (game.musicReady) {
                            startMusic();
                        } else {
                            // If not yet ready, wait for buffer-ready then start
                            backgroundMusic.addEventListener('canplaythrough', startMusic, { once: true });
                            // As a fallback, attempt to play anyway (browser may delay until buffered)
                            backgroundMusic.play().catch(() => {});
                        }
                    }).catch(error => console.error('Error enabling sound:', error));
                    document.removeEventListener('click', enableSound);
                };
                document.addEventListener('click', enableSound);
            }
            
            resetGame();
            initStarfield();
            // Music starts after user gesture via the click handler
            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            player.worldX = game.lastCheckpoint ? game.lastCheckpoint.x : 200;
            player.x = 200;
            player.y = groundTop() - player.height;
            player.velocity = 0;
            player.isAlive = true;
            player.jumping = false;
            game.jumpPressed = false;
            game.speedBoostTimer = 0;
            player.trail = [];
            game.effects = [];

            if (!game.lastCheckpoint) {
                game.score = 0;
                game.coinCount = 0;
                game.attempts++;
                game.obstacles = [];
                game.coins = [];
                game.particles = [];
                
                for(let i = 0; i < 10; i++) {
                    generateObstacles(800 + i * 400);
                }
            }

            updateScore();
            document.getElementById('attempts').textContent = `Attempts: ${game.attempts}`;
        }

        function togglePracticeMode() {
            game.isPracticeMode = !game.isPracticeMode;
            const button = event.target;
            button.textContent = game.isPracticeMode ? "NORMAL MODE" : "PRACTICE MODE";
        }

        function hideAllMenus() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('orientationPrompt').style.display = 'none';
        }

        function showMenu() {
            hideAllMenus();
            document.getElementById('menu').style.display = 'block';
            game.running = false;
            game.lastCheckpoint = null;
            canvas.style.display = 'none';
            backgroundMusic.pause();
            checkOrientation();
        }

        function pauseGame() {
            if (!game.running || !player.isAlive) return;
            game.isPaused = true;
            document.getElementById('pauseMenu').style.display = 'block';
            backgroundMusic.pause();
        }

        function resumeGame() {
            game.isPaused = false;
            hideAllMenus();
            playSound(backgroundMusic);
            requestAnimationFrame(gameLoop);
        }

        function playerDie() {
            if (!player.isAlive) return;  
            player.isAlive = false;
            game.running = false;  
            game.speedBoostTimer = 0;
            createParticles(player.x + player.width/2, player.y + player.height/2, '#00FFFF', 20);
            playSound(deathSound);
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = `Score: ${game.score}`;
            backgroundMusic.pause();
            // Don't reset currentTrackIndex here to keep track variety
        }

        function restartGame() {
            hideAllMenus();
            canvas.style.display = 'block';
            game.running = true;
            game.isPaused = false;
            game.lastCheckpoint = null;
            resetGame();
            playRandomTrack(); // Use playRandomTrack instead of playSound for background music
            requestAnimationFrame(gameLoop);
        }

        function updateParticles() {
            for(let i = game.particles.length - 1; i >= 0; i--) {
                const particle = game.particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= 0.02;
                if(particle.life <= 0) {
                    game.particles.splice(i, 1);
                }
            }
            // Update transient effects (e.g., shockwaves)
            for (let i = game.effects.length - 1; i >= 0; i--) {
                const fx = game.effects[i];
                if (fx.type === 'shockwave') {
                    fx.radius += fx.growth;
                    fx.alpha -= 0.04;
                    if (fx.alpha <= 0) game.effects.splice(i, 1);
                }
            }
        }

        function checkCollisions() {
            const playerHitbox = {
                x: player.worldX,
                y: player.y,
                width: player.width,
                height: player.height
            };

            for(let i = game.coins.length - 1; i >= 0; i--) {
                const coin = game.coins[i];
                if (!coin.collected && 
                    coin.x > player.worldX - 800 && 
                    coin.x < player.worldX + 800) {
                    const coinHitbox = {
                        x: coin.x,
                        y: coin.y,
                        width: coin.width,
                        height: coin.height
                    };
                    if (checkCollision(playerHitbox, coinHitbox)) {
                        game.coins.splice(i, 1);  
                        game.coinCount++;  
                        game.score += 100;  
                        createParticles(coin.x + coin.width/2, coin.y + coin.height/2, '#FFD700', 15);
                        if (soundEnabled) {
                            playSound(coinSound);
                        }
                    }
                }
            }

            for(const obstacle of game.obstacles) {
                if(obstacle.x > player.worldX - 800 && obstacle.x < player.worldX + 800) {
                    if(checkCollision(playerHitbox, obstacle)) {
                        if(obstacle.type === 'spike') {
                            playerDie();
                            return;
                        }
                        if(obstacle.type === 'platform' && player.velocity >= 0) {
                            if (player.y + player.height + player.velocity >= obstacle.y &&
                                player.y + player.height <= obstacle.y + player.velocity) {
                                player.y = obstacle.y - player.height;
                                player.velocity = 0;
                                player.jumping = false;
                                if (game.jumpPressed) {
                                    player.velocity = game.jumpForce;
                                    player.jumping = true;
                                    createParticles(player.x + player.width/2, player.y + player.height, '#00FFFF');
                                }
                            }
                        }
                        // Jump pad: bounce the player upwards strongly when landing on top
                        if (obstacle.type === 'pad' && player.velocity >= 0) {
                            if (player.y + player.height + player.velocity >= obstacle.y &&
                                player.y + player.height <= obstacle.y + player.velocity) {
                                player.y = obstacle.y - player.height;
                                player.velocity = Math.min(-1, game.jumpForce * 1.35);
                                player.jumping = true;
                                createParticles(player.x + player.width/2, player.y + player.height, '#00FFFF', 20);
                            }
                        }
                        // Air orb: if pressed while intersecting, grant an extra jump and consume orb
                        if (obstacle.type === 'orb' && !obstacle.used) {
                            if (game.jumpPressed) {
                                obstacle.used = true;
                                // remove the orb by shrinking; filtered later
                                player.velocity = game.jumpForce;
                                player.jumping = true;
                                createParticles(obstacle.x, obstacle.y, '#00FFFF', 15);
                            }
                        }
                        if (obstacle.type === 'portal' && !obstacle.activated) {
                            game.speedBoostTimer = 100;
                            obstacle.activated = true;
                            // spawn a shockwave effect at portal center
                            game.effects.push({
                                type: 'shockwave',
                                x: obstacle.x + obstacle.width/2,
                                y: obstacle.y + obstacle.height/2,
                                radius: 10,
                                growth: 6,
                                alpha: 0.6,
                            });
                        }
                    }
                }
            }

            if (player.y >= groundTop() - player.height) {
                player.y = groundTop() - player.height;
                player.velocity = 0;
                player.jumping = false;
                if (game.jumpPressed) {
                    player.velocity = game.jumpForce;
                    player.jumping = true;
                    createParticles(player.x + player.width/2, player.y + player.height, '#00FFFF');
                }
            }
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function updateScore() {
            document.getElementById('score').textContent = `Score: ${game.score} (Coins: ${game.coinCount})`;
        }

        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Background parallax stars
            drawStarfield();
            // Ground horizon
            const beat = (game.beat || 0);
            const lineThickness = 2 + Math.round(beat * 2);
            ctx.fillStyle = '#00FFFF';
            ctx.fillRect(0, canvas.height - 100, canvas.width, lineThickness);
            // Transient effects (shockwaves)
            game.effects.forEach(fx => {
                if (fx.type === 'shockwave') {
                    const sx = fx.x - game.cameraX;
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, fx.alpha);
                    ctx.strokeStyle = 'rgba(0,255,255,0.8)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(sx, fx.y, fx.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            });
            // Speed lines during boosts
            if (game.speedBoostTimer > 0 && game.showSpeedLines) {
                drawSpeedLines();
            }

            game.coins.forEach(coin => {
                if (!coin.collected && coin.x > player.worldX - 800 && coin.x < player.worldX + 800) {
                    const screenX = coin.x - game.cameraX;
                    coin.rotation += 0.1;
                    const gradient = ctx.createRadialGradient(screenX + 10, coin.y + 10, 0, screenX + 10, coin.y + 10, 15);
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenX + 10, coin.y + 10, 15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.save();
                    ctx.translate(screenX + 10, coin.y + 10);
                    ctx.rotate(coin.rotation);
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 10, 7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FFA500';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                }
            });

            game.obstacles.forEach(obstacle => {
                if(obstacle.x > player.worldX - 800 && obstacle.x < player.worldX + 800) {
                    const screenX = obstacle.x - game.cameraX;
                    ctx.fillStyle = obstacle.type === 'spike' ? '#FF0000' : '#00FFFF';
                    if(obstacle.type === 'spike') {
                        ctx.beginPath();
                        ctx.moveTo(screenX, obstacle.y + obstacle.height);
                        ctx.lineTo(screenX + obstacle.width/2, obstacle.y);
                        ctx.lineTo(screenX + obstacle.width, obstacle.y + obstacle.height);
                        ctx.closePath();
                        ctx.fill();
                    } else if (obstacle.type === 'portal') {
                        const t = (obstacle.phase = (obstacle.phase || 0) + 0.08);
                        // outer glow ring
                        ctx.save();
                        ctx.translate(screenX + obstacle.width/2, obstacle.y + obstacle.height/2);
                        ctx.rotate(Math.sin(t) * 0.2);
                        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 40);
                        grad.addColorStop(0, 'rgba(123,0,255,0.6)');
                        grad.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(0, 0, 40, 0, Math.PI * 2);
                        ctx.fill();
                        // inner gate
                        ctx.strokeStyle = obstacle.activated ? 'rgba(123,0,255,0.3)' : '#7B00FF';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 12 + Math.sin(t) * 2, 30 + Math.cos(t) * 3, 0, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    } else if (obstacle.type === 'pad') {
                        // glowing jump pad
                        const grad = ctx.createLinearGradient(0, obstacle.y, 0, obstacle.y + obstacle.height);
                        grad.addColorStop(0, '#00FFFF');
                        grad.addColorStop(1, '#007777');
                        ctx.fillStyle = grad;
                        ctx.shadowColor = '#00FFFF';
                        ctx.shadowBlur = 10;
                        ctx.fillRect(screenX, obstacle.y, obstacle.width, obstacle.height);
                        ctx.shadowBlur = 0;
                    } else if (obstacle.type === 'orb' && !obstacle.used) {
                        // floating orb
                        const t = (obstacle.phase = (obstacle.phase || 0) + 0.12);
                        const r = 12 + Math.sin(t) * 2;
                        const cx = screenX + obstacle.width/2;
                        const cy = obstacle.y + obstacle.height/2 + Math.sin(t*1.3) * 4;
                        const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r+8);
                        g.addColorStop(0, 'rgba(0,255,255,0.7)');
                        g.addColorStop(1, 'rgba(0,255,255,0)');
                        ctx.fillStyle = g;
                        ctx.beginPath();
                        ctx.arc(cx, cy, r+8, 0, Math.PI*2);
                        ctx.fill();
                        ctx.fillStyle = '#00FFFF';
                        ctx.beginPath();
                        ctx.arc(cx, cy, r/2, 0, Math.PI*2);
                        ctx.fill();
                    } else {
                        ctx.fillRect(screenX, obstacle.y, obstacle.width, obstacle.height);
                    }
                }
            });

            if (game.isPracticeMode) {
                game.checkpoints.forEach(checkpoint => {
                    if(checkpoint.x > player.worldX - 800 && checkpoint.x < player.worldX + 800) {
                        const screenX = checkpoint.x - game.cameraX;
                        ctx.fillStyle = '#00FF00';
                        ctx.globalAlpha = 0.5;
                        ctx.fillRect(screenX - 10, 0, 20, canvas.height);
                        ctx.globalAlpha = 1;
                    }
                });
            }

            const screenX = player.x;
            // draw neon trail behind player
            if (player.trail.length > 1) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (let i = 0; i < player.trail.length; i++) {
                    const p = player.trail[i];
                    const a = i / player.trail.length;
                    ctx.fillStyle = `rgba(0,255,255,${0.1 + a * 0.25})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 6 * a, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
            // draw player
            ctx.fillStyle = '#00FFFF';
            ctx.fillRect(screenX, player.y, player.width, player.height);

            game.particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.life;
                ctx.beginPath();
                ctx.arc(particle.x - game.cameraX, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        function gameLoop() {
            if (!game.running || game.isPaused) return;

            if (player.isAlive) {
                const currentSpeed = game.speed + (game.speedBoostTimer > 0 ? game.speedBoostAmount : 0);
                player.worldX += currentSpeed;
                player.velocity += game.gravity;
                player.y += player.velocity;

                // Update player neon trail (store recent positions)
                player.trail.push({ x: player.x + player.width/2, y: player.y + player.height/2 });
                if (player.trail.length > 12) player.trail.shift();

                

                checkCollisions();

                if (game.isPracticeMode && game.score > 0 && game.score % 500 === 0 && !game.checkpoints.some(cp => cp.x === player.worldX)) {
                    game.checkpoints.push({ x: player.worldX });
                    game.lastCheckpoint = game.checkpoints[game.checkpoints.length - 1];
                }

                game.cameraX = player.worldX - 200;
                
                while (game.obstacles[game.obstacles.length - 1].x < player.worldX + 1600) {
                    generateObstacles(game.obstacles[game.obstacles.length - 1].x + 400);
                }

                game.obstacles = game.obstacles.filter(obs => obs.x > player.worldX - 800);
                updateScore();
                if (game.speedBoostTimer > 0) game.speedBoostTimer--;
            }

            // Beat detection sampling
            if (game.analyser && game.freqData) {
                game.analyser.getByteFrequencyData(game.freqData);
                let sum = 0;
                const bins = Math.min(8, game.freqData.length);
                for (let i = 0; i < bins; i++) sum += game.freqData[i];
                const avg = sum / (bins * 255);
                const instant = Math.max(0, Math.min(1, (avg - 0.05) * 2.0));
                game.beatSmoothed = game.beatSmoothed * 0.85 + instant * 0.15;
                game.beat = game.beatSmoothed;
            }

            updateParticles();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                game.jumpPressed = true;
                if (game.running && player.isAlive && !player.jumping) {
                    player.velocity = (game.gravity > 0) ? game.jumpForce : -game.jumpForce;
                    player.jumping = true;
                    createParticles(player.x + player.width/2, player.y + player.height, '#00FFFF');
                }
            } else if (e.code === 'Escape') {
                if (game.running && player.isAlive) {
                    if (game.isPaused) resumeGame();
                    else pauseGame();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') game.jumpPressed = false;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            game.jumpPressed = true;
            if (game.running && player.isAlive && !player.jumping) {
                player.velocity = (game.gravity > 0) ? game.jumpForce : -game.jumpForce;
                player.jumping = true;
                createParticles(player.x + player.width/2, player.y + player.height, '#00FFFF');
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            game.jumpPressed = false;
        });

        function resizeCanvas() {
            if (isMobile()) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            } else {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function checkOrientation() {
            if (isMobile()) {
                const isPortrait = window.innerHeight > window.innerWidth;
                document.getElementById('orientationPrompt').style.display = isPortrait ? 'block' : 'none';
            } else {
                document.getElementById('orientationPrompt').style.display = 'none';
            }
        }
        window.addEventListener('resize', checkOrientation);
        window.addEventListener('orientationchange', checkOrientation);
        checkOrientation();
    </script>
</body>
</html>